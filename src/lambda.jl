module LambdaHandling

import Base.show

# This controls the debug print level.  0 prints nothing.  3 print everything.
DEBUG_LVL=0

@doc """
Control how much debugging output is generated by this module.  
Takes one Int argument where: 0 prints nothing. 
Increasing values print more debugging output up to a maximum of debug level 3.
"""
function set_debug_level(x)
    global DEBUG_LVL = x
end

@doc """
Calls print to print a message if the incoming debug level is greater than or equal to the level specified in set_debug_level().
First argument: the detail level of the debugging information.  Higher numbers for higher detail.
Second+ arguments: the message to print if the debug level is satisfied.
"""
function dprint(level,msgs...)
    if(DEBUG_LVL >= level)
        print(msgs...)
    end
end

@doc """
Calls println to print a message if the incoming debug level is greater than or equal to the level specified in set_debug_level().
First argument: the detail level of the debugging information.  Higher numbers for higher detail.
Second+ arguments: the message to print if the debug level is satisfied.
"""
function dprintln(level,msgs...)
    if(DEBUG_LVL >= level)
        println(msgs...)
    end
end

@doc """
Represents the triple stored in a lambda's args[2][1].
The triple is 1) the Symbol of an input parameter or local variable, 2) the type of that Symbol, and 3) a descriptor for that symbol.
The descriptor can be 0 if the variable is an input parameter, 1 if it is captured, 2 if it is assigned within the function, 4 if
it is assigned by an inner function, 8 if it is const, and 16 if it is assigned to statically only once by the function.
"""
type VarDef
  name :: Symbol
  typ
  desc :: Int64

  function VarDef(n, t, d)
    new(n, t, d)
  end
end

@doc """
An internal format for storing a lambda expression's args[1] and args[2].
The input parameters are stored as a Set since they must be unique and it makes for faster searching.
The VarDefs are stored as a dictionary from symbol to VarDef since type lookups are reasonably frequent and need to be fast.
The GenSym part (args[2][3]) is stored as an array since GenSym's are indexed.
Captured_outer_vars and static_parameter_names are stored as arrays for now since we don't expect them to be changed much.
"""
type LambdaInfo
  input_params :: Set{Symbol}
  var_defs     :: Dict{Symbol,VarDef}
  gen_syms     :: Array{Any,1}
  captured_outer_vars :: Array{Any,1}
  static_parameter_names :: Array{Any,1}

  function LambdaInfo()
    new(Set{Symbol}(), Dict{Symbol,VarDef}(), Any[], Any[], Any[])
  end
end

@doc """
Returns the type of a Symbol or GenSym in "x" from LambdaInfo in "li".
"""
function getType(x, li :: LambdaInfo)
  if typeof(x) == Symbol
    return li.var_defs[x].typ
  elseif typeof(x) == GenSym
    return li.gen_syms[x.id + 1]
  else
    throw(string("getType called with neither Symbol or GenSym input.  Instead the input type was ", typeof(x)))
  end
end

@doc """
Returns the VarDef for a Symbol in LambdaInfo in "li"
"""
function getVarDef(s :: Symbol, li :: LambdaInfo)
  return li.var_defs[s]
end

@doc """
Returns true if the Symbol in "s" is an input parameter in LambdaInfo in "li".
"""
function isInputParameter(s :: Symbol, li :: LambdaInfo)
  return in(s, li.input_params)
end

@doc """
Returns true if the Symbol in "s" is a local variable in LambdaInfo in "li".
"""
function isLocalVariable(s :: Symbol, li :: LambdaInfo)
  return haskey(li.var_defs, s) && !isInputParameter(s, li)
end

@doc """
Adds a new local variable with the given Symbol "s", type "typ", descriptor "desc" in LambdaInfo "li".
Returns true if the variable already existed and its type and descriptor were updated, false otherwise.
"""
function addLocalVariable(s :: Symbol, typ, desc :: Int64, li :: LambdaInfo)
  assert(!isInputParameter(s, li))
  # If it is already a local variable then just update its type and desc.
  if haskey(li.var_defs, s)
    var_def      = li.var_defs[s]
    dprintln(3,"addLocalVariable ", s, " already exists with type ", var_def.typ)
    var_def.typ  = typ
    var_def.desc = desc
    return true
  end

  li.var_defs[s] = VarDef(s, typ, desc)
  dprintln(3,"addLocalVariable = ", s)

  return false
end

@doc """
Add a new GenSym to the LambdaInfo in "li" with the given type in "typ".
Returns the new GenSym.
"""
function addGenSym(typ, li :: LambdaInfo)
  push!(li.gen_syms, typ)
  return GenSym(length(li.gen_syms) - 1) 
end

@doc """
Convert the lambda expression's args[1] from array of any to Set of Symbol to be stored in LambdaInfo.
We make sure that each element of the array is indeed a Symbol.
"""
function createVarSet(x :: Array{Any,1})
  ret = Set{Symbol}()
  for i = 1:length(x)
    assert(typeof(x[i]) == Symbol)
    push!(ret, x[i])
  end
  return ret
end

@doc """
Convert the lambda expression's args[2][1] from Array{Array{Any,1},1} to a Dict{Symbol,VarDef}.
The internal triples are extracted and asserted that name and desc are of the appropriate type.
"""
function createVarDict(x :: Array{Any, 1})
  ret = Dict{Symbol,VarDef}()
  dprintln(1,"createVarDict ", x)
  for i = 1:length(x)
    dprintln(1,"x[i] = ", x[i])
    name = x[i][1]
    typ  = x[i][2]
    desc = x[i][3]
    if typeof(name) != Symbol
      dprintln(0, "name is not of type symbol ", name, " type = ", typeof(name))
    end
    if typeof(desc) != Int64
      dprintln(0, "desc is not of type Int64 ", desc, " type = ", typeof(desc))
    end
    ret[name] = VarDef(name, typ, desc)
  end
  return ret
end

@doc """
Convert a lambda expression into our internal storage format, LambdaInfo.
The input is asserted to be an expression whose head is :lambda.
"""
function lambdaExprToLambdaInfo(lambda :: Expr)
  assert(lambda.head == :lambda)

  ret = LambdaInfo()
  # Convert array of input parameters in lambda.args[1] into a searchable Set.
  ret.input_params = createVarSet(lambda.args[1]) 
  # We call the second part of the lambda metadata.
  meta = lambda.args[2]
  dprintln(1,"meta = ", meta)
  # Create a searchable dictionary mapping symbols to their VarDef information.
  ret.var_defs = createVarDict(meta[1])
  ret.captured_outer_vars = meta[2]
  ret.gen_syms = meta[3]
  ret.static_parameter_names = meta[4]

  return ret
end

@doc """
Convert the set of Symbols corresponding to the input parameters back to an array for inclusion in a new lambda expression.
"""
function setToArray(x :: Set{Symbol})
  ret = Symbol[]
  for s in x
    push!(ret, s)
  end
  return ret
end

@doc """
Convert the Dict{Symbol,VarDef} internal storage format from a dictionary back into an array of Any triples.
"""
function dictToArray(x :: Dict{Symbol,VarDef})
  ret = Any[]
  for s in x
    push!(ret, [s.name; s.typ; s.desc])
  end
  return ret
end

@doc """
Create the args[2] part of a lambda expression given an object of our internal storage format LambdaInfo.
"""
function createMeta(lambdaInfo :: LambdaInfo)
  ret = Any[]

  push!(ret, dictToArray(lambdaInfo.var_defs))
  push!(ret, captured_outer_vars)
  push!(ret, gen_syms)
  push!(ret, static_parameter_names)

  return ret
end

@doc """
Convert our internal storage format, LambdaInfo, back into a lambda expression.
This takes a LambdaInfo and a body as input parameters.
This body can be a body expression or you can pass "nothing" if you want but then you will probably need to set the body in args[3] manually by yourself.
"""
function lambdaInfoToLambdaExpr(lambdaInfo :: LambdaInfo, body)
  return Expr(:lambda, setToArray(lambdaInfo.input_params), createMeta(lambdaInfo), body)
end

@doc """
Returns the body expression part of a lambda expression.
"""
function getBody(lambda :: Expr)
  assert(lambda.head == :lambda)
  return lambda.args[3]
end

@doc """
Returns an array of Symbols corresponding to those parameters to the method that are going to be passed by reference.
In short, isbits() types are passed by value and !isbits() types are passed by reference.
"""
function getRefParams(lambdaInfo :: LambdaInfo)
  ret = Symbol[]

  input_vars = lambdaInfo.input_params
  var_types  = lambdaInfo.var_defs

  dprintln(3,"input_vars = ", input_vars)
  dprintln(3,"var_types = ", var_types)

  for iv in input_vars
    dprintln(3,"iv = ", iv, " type = ", typeof(iv))
    if haskey(var_types, iv)
      var_def = var_types[iv] 
      if !isbits(var_def.typ)
        push!(ret, iv)
      end
    else
      throw(string("Didn't find parameter variable ", iv, " in type list."))
    end
  end

  return ret
end

end
